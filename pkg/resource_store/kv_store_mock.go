// Automatically generated by MockGen. DO NOT EDIT!
// Source: vendor/github.com/docker/libkv/store/store.go

package resourcestore

import (
	"github.com/docker/libkv/store"
	gomock "github.com/golang/mock/gomock"
)

// Mock of Store interface
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *_MockStoreRecorder
}

// Recorder for MockStore (not exported)
type _MockStoreRecorder struct {
	mock *MockStore
}

func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &_MockStoreRecorder{mock}
	return mock
}

func (_m *MockStore) EXPECT() *_MockStoreRecorder {
	return _m.recorder
}

func (_m *MockStore) Put(key string, value []byte, options *store.WriteOptions) error {
	ret := _m.ctrl.Call(_m, "Put", key, value, options)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockStoreRecorder) Put(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Put", arg0, arg1, arg2)
}

func (_m *MockStore) Get(key string) (*store.KVPair, error) {
	ret := _m.ctrl.Call(_m, "Get", key)
	ret0, _ := ret[0].(*store.KVPair)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) Get(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Get", arg0)
}

func (_m *MockStore) Delete(key string) error {
	ret := _m.ctrl.Call(_m, "Delete", key)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockStoreRecorder) Delete(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Delete", arg0)
}

func (_m *MockStore) Exists(key string) (bool, error) {
	ret := _m.ctrl.Call(_m, "Exists", key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) Exists(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Exists", arg0)
}

func (_m *MockStore) Watch(key string, stopCh <-chan struct{}) (<-chan *store.KVPair, error) {
	ret := _m.ctrl.Call(_m, "Watch", key, stopCh)
	ret0, _ := ret[0].(<-chan *store.KVPair)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) Watch(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Watch", arg0, arg1)
}

func (_m *MockStore) WatchTree(directory string, stopCh <-chan struct{}) (<-chan []*store.KVPair, error) {
	ret := _m.ctrl.Call(_m, "WatchTree", directory, stopCh)
	ret0, _ := ret[0].(<-chan []*store.KVPair)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) WatchTree(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "WatchTree", arg0, arg1)
}

func (_m *MockStore) NewLock(key string, options *store.LockOptions) (store.Locker, error) {
	ret := _m.ctrl.Call(_m, "NewLock", key, options)
	ret0, _ := ret[0].(store.Locker)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) NewLock(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "NewLock", arg0, arg1)
}

func (_m *MockStore) List(directory string) ([]*store.KVPair, error) {
	ret := _m.ctrl.Call(_m, "List", directory)
	ret0, _ := ret[0].([]*store.KVPair)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) List(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "List", arg0)
}

func (_m *MockStore) DeleteTree(directory string) error {
	ret := _m.ctrl.Call(_m, "DeleteTree", directory)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockStoreRecorder) DeleteTree(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "DeleteTree", arg0)
}

func (_m *MockStore) AtomicPut(key string, value []byte, previous *store.KVPair, options *store.WriteOptions) (bool, *store.KVPair, error) {
	ret := _m.ctrl.Call(_m, "AtomicPut", key, value, previous, options)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(*store.KVPair)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockStoreRecorder) AtomicPut(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "AtomicPut", arg0, arg1, arg2, arg3)
}

func (_m *MockStore) AtomicDelete(key string, previous *store.KVPair) (bool, error) {
	ret := _m.ctrl.Call(_m, "AtomicDelete", key, previous)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockStoreRecorder) AtomicDelete(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "AtomicDelete", arg0, arg1)
}

func (_m *MockStore) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockStoreRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

// Mock of Locker interface
type MockLocker struct {
	ctrl     *gomock.Controller
	recorder *_MockLockerRecorder
}

// Recorder for MockLocker (not exported)
type _MockLockerRecorder struct {
	mock *MockLocker
}

func NewMockLocker(ctrl *gomock.Controller) *MockLocker {
	mock := &MockLocker{ctrl: ctrl}
	mock.recorder = &_MockLockerRecorder{mock}
	return mock
}

func (_m *MockLocker) EXPECT() *_MockLockerRecorder {
	return _m.recorder
}

func (_m *MockLocker) Lock(stopChan chan struct{}) (<-chan struct{}, error) {
	ret := _m.ctrl.Call(_m, "Lock", stopChan)
	ret0, _ := ret[0].(<-chan struct{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockLockerRecorder) Lock(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Lock", arg0)
}

func (_m *MockLocker) Unlock() error {
	ret := _m.ctrl.Call(_m, "Unlock")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockLockerRecorder) Unlock() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Unlock")
}
